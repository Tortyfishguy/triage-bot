from flask import Flask, request
import os
import json
import torch
import threading
import requests
import zipfile

from firebase_admin import credentials, firestore, initialize_app, storage
from google.cloud import storage as gcs_storage
from transformers import AutoTokenizer, AutoModelForSequenceClassification
from linebot import LineBotApi, WebhookHandler
from linebot.models import MessageEvent, TextMessage, TextSendMessage

# ‚úÖ ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ Firebase Storage URL (‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡∏≠‡∏á‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Ñ‡∏Ñ‡∏∏‡∏ì)
FIREBASE_JSON_URL = "https://firebasestorage.googleapis.com/v0/b/esi-triage-bot-ab4ac.firebasestorage.app/o/esi-triage-bot-ab4ac-firebase-adminsdk-fbsvc-4722ca62ea.json?alt=media"
MODEL_ZIP_URL = "https://firebasestorage.googleapis.com/v0/b/esi-triage-bot-ab4ac.firebasestorage.app/o/esi_model_clean.zip?alt=media"

# ‚úÖ ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡πá‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏ö‡∏ô‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå
LOCAL_CREDENTIALS_PATH = "/tmp/firebase-adminsdk.json"
LOCAL_MODEL_PATH = "/tmp/esi_model"

# ‚úÖ ‡∏î‡∏∂‡∏á‡πÑ‡∏ü‡∏•‡πå Firebase Credentials JSON ‡∏à‡∏≤‡∏Å Firebase Storage
def download_firebase_credentials():
    if not os.path.exists(LOCAL_CREDENTIALS_PATH):
        print("üîΩ Downloading Firebase Credentials JSON...")
        response = requests.get(FIREBASE_JSON_URL)
        with open(LOCAL_CREDENTIALS_PATH, "wb") as file:
            file.write(response.content)
        os.environ["GOOGLE_APPLICATION_CREDENTIALS"] = LOCAL_CREDENTIALS_PATH
        print("‚úÖ Firebase Credentials Downloaded")

# ‚úÖ ‡∏î‡∏∂‡∏á‡πÑ‡∏ü‡∏•‡πå‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏à‡∏≤‡∏Å Firebase Storage
def download_and_extract_model():
    if not os.path.exists(LOCAL_MODEL_PATH):
        print("üîΩ Downloading Model ZIP...")
        response = requests.get(MODEL_ZIP_URL)
        zip_path = "/tmp/esi_model.zip"
        with open(zip_path, "wb") as file:
            file.write(response.content)
        
        print("üì¶ Extracting Model...")
        with zipfile.ZipFile(zip_path, "r") as zip_ref:
            zip_ref.extractall("/tmp/")
        print("‚úÖ Model Extracted")

# ‚úÖ ‡πÇ‡∏´‡∏•‡∏î Environment Variables
LINE_ACCESS_TOKEN = os.getenv("LINE_ACCESS_TOKEN")
LINE_CHANNEL_SECRET = os.getenv("LINE_CHANNEL_SECRET")

# ‚úÖ ‡πÇ‡∏´‡∏•‡∏î Firebase Credentials
download_firebase_credentials()
cred = credentials.Certificate(LOCAL_CREDENTIALS_PATH)
firebase_app = initialize_app(cred)
db = firestore.client()

# ‚úÖ ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏• (‡∏•‡∏î‡∏Ç‡∏ô‡∏≤‡∏î‡πÄ‡∏õ‡πá‡∏ô FP16 ‡πÅ‡∏•‡∏∞‡πÉ‡∏ä‡πâ GPU ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ)
download_and_extract_model()
MODEL_PATH = "/tmp/esi_model"

device = "cuda" if torch.cuda.is_available() else "cpu"
tokenizer = AutoTokenizer.from_pretrained(MODEL_PATH)
model = AutoModelForSequenceClassification.from_pretrained(
    MODEL_PATH,
    num_labels=5,
    torch_dtype=torch.float16 if device == "cuda" else torch.float32  # ‡πÉ‡∏ä‡πâ Half-Precision ‡∏ö‡∏ô GPU
).to(device)

# ‚úÖ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå CUDA Memory
def clear_cuda_memory():
    if torch.cuda.is_available():
        torch.cuda.empty_cache()
        torch.cuda.ipc_collect()
        print("üßπ Cleared Unused CUDA Memory")

# ‚úÖ ‡∏™‡∏£‡πâ‡∏≤‡∏á Flask App
app = Flask(__name__)
line_bot_api = LineBotApi(LINE_ACCESS_TOKEN)
handler = WebhookHandler(LINE_CHANNEL_SECRET)

# ‚úÖ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏õ‡∏£‡∏∞‡πÄ‡∏°‡∏¥‡∏ô ESI
def classify_esi(text):
    inputs = tokenizer(text, return_tensors="pt", truncation=True, padding=True, max_length=256).to(device)

    with torch.no_grad():
        outputs = model(**inputs)
    
    predicted_esi = torch.argmax(outputs.logits, dim=1).item() + 1

    # ‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå CUDA Memory ‡∏´‡∏•‡∏±‡∏á‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÄ‡∏™‡∏£‡πá‡∏à
    clear_cuda_memory()

    return predicted_esi

# ‚úÖ Webhook ‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏ó‡∏±‡∏ô‡∏ó‡∏µ + ‡πÉ‡∏ä‡πâ Threading
@app.route("/webhook", methods=["POST"])
def webhook():
    signature = request.headers.get("X-Line-Signature", "No Signature")
    body = request.get_data(as_text=True)

    print(f"üì© Received Webhook: {body}")
    print(f"üîê Signature: {signature}")

    if not signature:
        print("‚ùå Missing X-Line-Signature")
        return "Missing Signature", 400

    # ‡πÉ‡∏ä‡πâ Thread ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ Webhook ‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
    def handle_message_async():
        try:
            handler.handle(body, signature)
        except Exception as e:
            print(f"‚ö†Ô∏è Error: {str(e)}")

    threading.Thread(target=handle_message_async).start()
    
    return "OK", 200  # ‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏ó‡∏±‡∏ô‡∏ó‡∏µ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô timeout

# ‚úÖ ‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏à‡∏≤‡∏Å LINE
@handler.add(MessageEvent, message=TextMessage)
def handle_message(event):
    text = event.message.text
    esi_level = classify_esi(text)  # ‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏õ‡∏£‡∏∞‡πÄ‡∏°‡∏¥‡∏ô‡∏£‡∏∞‡∏î‡∏±‡∏ö ESI

    # ‡πÅ‡∏õ‡∏•‡∏á‡∏£‡∏∞‡∏î‡∏±‡∏ö ESI ‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏µ‡πà‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡∏á‡πà‡∏≤‡∏¢
    if esi_level in [1, 2]:
        response_text = f"üö® ‡∏≠‡∏≤‡∏Å‡∏≤‡∏£‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏£‡∏±‡∏Å‡∏©‡∏≤‡∏ó‡∏µ‡πà‡∏´‡πâ‡∏≠‡∏á‡∏â‡∏∏‡∏Å‡πÄ‡∏â‡∏¥‡∏ô‡∏ó‡∏±‡∏ô‡∏ó‡∏µ! (ESI {esi_level})"
    elif esi_level == 3:
        response_text = f"ü©∫ ‡∏Ñ‡∏ß‡∏£‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡πÄ‡∏°‡∏¥‡∏ô‡πÇ‡∏î‡∏¢‡πÅ‡∏û‡∏ó‡∏¢‡πå (ESI {esi_level})"
    else:
        response_text = f"üíä ‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÉ‡∏´‡πâ‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏ó‡∏µ‡πà‡πÇ‡∏£‡∏á‡∏û‡∏¢‡∏≤‡∏ö‡∏≤‡∏•‡πÉ‡∏ô‡∏ß‡∏±‡∏ô‡∏ñ‡∏±‡∏î‡πÑ‡∏õ (ESI {esi_level})"

    # ‚úÖ ‡πÉ‡∏ä‡πâ Threading ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ LINE ‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡πÄ‡∏£‡πá‡∏ß‡∏Ç‡∏∂‡πâ‡∏ô
    def reply():
        line_bot_api.reply_message(event.reply_token, TextSendMessage(text=response_text))

    thread = threading.Thread(target=reply)
    thread.start()

# ‚úÖ ‡∏£‡∏±‡∏ô‡πÅ‡∏≠‡∏õ (‡πÉ‡∏ä‡πâ Uvicorn Worker ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏•‡∏î RAM)
if __name__ == "__main__":
    from uvicorn import run
    run(app, host="0.0.0.0", port=10000, workers=1)
